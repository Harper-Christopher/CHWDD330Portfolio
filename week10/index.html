<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>WDD 330 Portfolio</title>
        <link rel="stylesheet" href="css/small.css">
    </head>
    <body onload="refreshWeeks()">
        <h1>WDD 330 Portfolio</h1>
        <h2>Week10</h1>
        <ol id="weeks"> 
            <li>Client-side form validation helps ensure data submitted matches the requirements set forth in the various form controls.</li>
            <li>Client-side validation should not be considered an exhaustive security measure</li>
            <li>Your apps should always perform security checks on any form-submitted data on the server-side as well as the client-side, because client-side validation is too easy to bypass, so malicious users can still easily send bad data through to your server.</li>
            <li>If the information is correctly formatted, the application allows the data to be submitted to the server and (usually) saved in a database; if the information isn't correctly formatted, it gives the user an error message explaining what needs to be corrected, and lets them try again.</li>
            <li>We want to get the right data, in the right format. Our applications won't work properly if our users' data is stored in the wrong format, is incorrect, or is omitted altogether.</li>
            <li>We want to protect our users' data. Forcing our users to enter secure passwords makes it easier to protect their account information.</li>
            <li>We want to protect ourselves. There are many ways that malicious users can misuse unprotected forms to damage the application</li>
            <li>The fetch specification differs from jQuery.ajax() in three main ways:</li>
            <li>The Promise returned from fetch() won’t reject on HTTP error status even if the response is an HTTP 404 or 500. Instead, it will resolve normally (with ok status set to false), and it will only reject on network failure or if anything prevented the request from completing.</li>
            <li>fetch() won't can receive cross-site cookies; you can’t can establish a cross site session using fetch. Set-Cookie headers from other sites are silently ignored.</li>
            <li>fetch won’t send cookies, unless you set the credentials init option. (Since Aug 25, 2017. The spec changed the default credentials policy to same-origin. Firefox changed since 61.0b13.)</li>
            <li>fetch('http://example.com/movies.json')
                .then(response => response.json())
                .then(data => console.log(data)); </li>
        
            <li>// Example POST method implementation:
                async function postData(url = '', data = {}) {
                  // Default options are marked with *
                  const response = await fetch(url, {
                    method: 'POST', // *GET, POST, PUT, DELETE, etc.
                    mode: 'cors', // no-cors, *cors, same-origin
                    cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
                    credentials: 'same-origin', // include, *same-origin, omit
                    headers: {
                      'Content-Type': 'application/json'
                      // 'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    redirect: 'follow', // manual, *follow, error
                    referrerPolicy: 'no-referrer', // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
                    body: JSON.stringify(data) // body data type must match "Content-Type" header
                  });
                  return response.json(); // parses JSON response into native JavaScript objects
                }
                
                postData('https://example.com/answer', { answer: 42 })
                  .then(data => {
                    console.log(data); // JSON data parsed by `data.json()` call
                  });</li>
            <li>Use fetch() to POST JSON-encoded data.</li>
            <li>const data = { username: 'example' };

                fetch('https://example.com/profile', {
                  method: 'POST', // or 'PUT'
                  headers: {
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify(data),
                })
                .then(response => response.json())
                .then(data => {
                  console.log('Success:', data);
                })
                .catch((error) => {
                  console.error('Error:', error);
                });</li>
                <li>A fetch() promise will reject with a TypeError when a network error is encountered or CORS is misconfigured on the server-side, although this usually means permission issues or similar — a 404 does not constitute a network error, for example. An accurate check for a successful fetch() would include checking that the promise resolved, then checking that the Response.ok property has a value of true. The code would look something like this:</li>
                <li>fetch('flowers.jpg')
                    .then(response => {
                      if (!response.ok) {
                        throw new Error('Network response was not ok');
                      }
                      return response.blob();
                    })
                    .then(myBlob => {
                      myImage.src = URL.createObjectURL(myBlob);
                    })
                    .catch(error => {
                      console.error('There has been a problem with your fetch operation:', error);
                    });</li>
                </ol>
    
    <h3>Questions:</h3>
    <ol>
        <li></li>
    </ol>

        <!-- <h3>W10 Projects</h3>
        <a href="#">Click Here for W10 Project</a> -->
        

        <h3>W10 Team Activity</h3>
        <a href="team_project.html">Click Here for W10 Team Activity</a>
        <script src="js/main.js"></script>    
    </body>  
</html>